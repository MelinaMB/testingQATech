Como debe estar estructurado el proyecto

proyecto---->main.py
        ---->conftest.py
        ---->test---->test_login.py
                 ---->test_carrito.py
        ---->utils.py

Con respecto a lo que deberia hacer con la parte logica de la pagina
Yo deberia tener en cada paso de mi pagina separado en distintas funciones
y despues las voy a llamar adentro del test para hacer las validaciones que yo necesite
yo no deberia tener por ejemplo esto en el test:

que es buscar un elemento en la pagina
productos = driver.find_elements(By.CLASS_NAME,"inventory_item")

No es una buena practica, lo que deberia tener en utils es una funcion que haga exactamente eso globalizarla en caso de requerirlo y 
mandarla a la prueba 

Patrones
- Page Object Model(POM):
Un patron especifico para automatizacion que encapsula cada pantalla en una clase y expone metodos de alto nivel.
Propone representar cada pagina o vista de tu aplicacion como un objeto(clase) que:
. Conoce sus elementos(locators)
. Sabe actuar sobre ellos mediante métodos significativos
. Oculta detalles de UI al resto del código
De esta forma separo las responsabilidades, la logica de la pagina esta separada de los test
Mantenibilidad: Si cambia el HTML, solo modificas la clase Page
Reutilizacion: Puedes usar los mismos metodos en multiples tests
Legibilidad: los tests quedan mas limpios y expresivos

Manejar los datos
- Deben estar separados del codigo los datos.
Para tener un mantenimiento mas facil del codigo y la reutilizacion 
sin tener que modificar todo el codigo o la modificar la logica.
La idea es que esten en un archivo distinto y exportarlo desde ahi los datos 
Tener los datos que se prueban por un lado y por el otro tener la logica de como se prueba

funciones de pytest

find_elements(by, value) espera 2 parametros separados 
por lo que se espera que se desempaquete
ej: productos = self.driver.find_elements(*self._INVENTORY_ITEMS)

EC.visibility_of_all_elements_located(locator) espera un solo paremetro (una tupla completa)
Por lo que en este caso no hace falta desempaquetar
ej:self.wait.until(EC.visibility_of_all_elements_located(self._INVENTORY_ITEMS))


Faker
Es una libreria que genera datos falsos aleatorios pero realistas
Es util:
-Para no crear manualmente 1000 usuarios de prueba
-Cuando necesitas datos unicos en cda ejecucion
-Cuando quieres probar con diferentes tipos de caracteres y formatos
-Cuando buscas descubrir bugs con datos inesperados 

API 
puente/enlace 
API utilizada Reqres
@pytest.mark...
py -m pytest -m api -v  
va a agarrar todas los test y los va a correr uno tras otro
me aparecen advertencias porque no reconose en este caso el mark personalizado que se llama api
para esto tengo que agregarlo en un archivo llamado pytest.ini
@pytest.mark.skip(reason="Desactivada porque sigue en desarollo") puedo saltear un test utilizando el marcador skip
hay marcadores prediseñados

Captura de pantalla cuando hay un error
